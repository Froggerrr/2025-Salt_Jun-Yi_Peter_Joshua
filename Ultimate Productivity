# gamified_productivity_full.py
import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import random, math, os

SPRITE_PATH = "/mnt/data/90d47392-e48f-407f-9cce-a26714a986b3.png"

# ---------------- Main Window ----------------
root = tk.Tk()
root.title("Gamified Productivity Tracker")
root.geometry("820x720")
root.configure(bg="#f0f8ff")

# ---------------- Globals ----------------
stopwatch_seconds = 0
stopwatch_running = False
session_xp = 0
session_points = 0
total_xp = 0
total_points = 0
xp_multiplier = 1.0

level = 1
current_xp = 0
xp_needed = 100

streak = 0
last_streak_date = None

questions_for_session = []
current_question_index = 0
num_questions = 0

player_badges = []

# Badge definitions with updated probabilities
BADGES = [
    {"key": "Triangle", "chance": 65.0},   # 65%
    {"key": "Circle",   "chance": 30.0},   # 30%
    {"key": "Square",   "chance": 4.9},    # 4.9%
    {"key": "Hexagon",  "chance": 0.1},    # 0.1%
]

def badge_random_choice():
    r = random.random() * 100
    cum = 0.0
    for b in BADGES:
        cum += b["chance"]
        if r <= cum:
            return b["key"]
    return BADGES[-1]["key"]

# ---------------- Load/crop sprite sheet (your uploaded image) ----------------
use_sprite_images = False
sprite_imgs = {}  # map name -> PhotoImage

if os.path.exists(SPRITE_PATH):
    try:
        master = tk.PhotoImage(file=SPRITE_PATH)
        mw, mh = master.width(), master.height()
        # assume sprite grid: 3 cols x 2 rows
        cols, rows = 3, 2
        cw, ch = mw // cols, mh // rows
        # mapping: top row left->right: Hexagon, Square, Circle ; bottom-left: Triangle
        mapping = {
            "Hexagon": (0,0),
            "Square":  (1,0),
            "Circle":  (2,0),
            "Triangle":(0,1),
        }
        for name,(col,row) in mapping.items():
            x1 = col * cw; y1 = row * ch; x2 = x1 + cw; y2 = y1 + ch
            cropped = tk.PhotoImage(width=cw, height=ch)
            # attempt a few copy styles for broad compatibility
            copied = False
            try:
                # preferred: use tk call
                cropped.tk.call(cropped, 'copy', master, '-from', x1, y1, x2, y2, '-to', 0, 0)
                copied = True
            except Exception:
                try:
                    # try PhotoImage.copy variant
                    cropped.copy(master, x1, y1, x2, y2)
                    copied = True
                except Exception:
                    try:
                        cropped.copy(master, from_coords=(x1,y1,x2,y2))
                        copied = True
                    except Exception:
                        copied = False
            if not copied:
                raise RuntimeError("Could not crop PhotoImage; will fallback to vector draw.")
            sprite_imgs[name] = cropped
        use_sprite_images = True
    except Exception:
        use_sprite_images = False

# ---------------- Utility: draw fallback shapes (if images not usable) ----------------
def draw_shape_on_canvas(canvas, shape_name, size=80, fill="#1e90ff", outline="black"):
    canvas.delete("all")
    w, h = size, size
    cx, cy = w/2, h/2
    if shape_name == "Circle":
        canvas.create_oval(cx- w*0.35, cy - h*0.35, cx + w*0.35, cy + h*0.35, fill=fill, outline=outline, width=2)
    elif shape_name == "Square":
        m = w*0.18
        canvas.create_rectangle(m,m,w-m,h-m, fill=fill, outline=outline, width=2)
    elif shape_name == "Triangle":
        pts = [cx, cy - h*0.34, cx - w*0.34, cy + h*0.22, cx + w*0.34, cy + h*0.22]
        canvas.create_polygon(pts, fill=fill, outline=outline, width=2)
    elif shape_name == "Hexagon":
        r = w*0.34
        pts=[]
        for i in range(6):
            ang = math.radians(60*i - 30)
            pts.extend([cx + r*math.cos(ang), cy + r*math.sin(ang)])
        canvas.create_polygon(pts, fill=fill, outline=outline, width=2)
    else:
        canvas.create_text(cx, cy, text=shape_name, font=("Arial",10))

# ---------------- Math Question Generators ----------------
def generate_circle_question_and_answer():
    # Use the exact logic you provided, but packaged into a function that returns (text, answer)
    G=0; F=0; C=1
    # use smaller ranges like you specified
    while G**2 + F**2 - C <= 0:
        G = random.randint(-20,20)
        F = random.randint(-20,20)
        C = random.randint(-50,50)
    # create the nicely formatted equation string following your sign rules
    def term_str(coef, var):
        if coef == 0:
            return ""
        if var == "":
            # constant
            if coef > 0:
                return f"+ {coef}"
            else:
                return f"- {-coef}"
        if coef == 1:
            return f"+ {var}"
        if coef == -1:
            return f"- {var}"
        if coef > 0:
            return f"+ {coef}{var}"
        return f"- {-coef}{var}"
    parts = ["x\u00b2 + y\u00b2"]
    # Gx term
    if G != 0:
        if G > 0:
            if G == 1: parts.append("+ x")
            else: parts.append(f"+ {G}x")
        else:
            if G == -1: parts.append("- x")
            else: parts.append(f"- {-G}x")
    # Fy term
    if F != 0:
        if F > 0:
            if F == 1: parts.append("+ y")
            else: parts.append(f"+ {F}y")
        else:
            if F == -1: parts.append("- y")
            else: parts.append(f"- {-F}y")
    # C term (constant)
    if C != 0:
        if C > 0:
            parts.append(f"+ {C}")
        else:
            parts.append(f"- {-C}")
    # join and clean spacing
    eq = " ".join(parts).replace("+ -", "- ").strip()
    # final question text
    question_text = f"A circle has an equation of {eq}. Find the coordinates of the center and the radius of the circle."
    # compute center (h,k) and radius r
    # standard: x^2 + y^2 + G x + F y + C = 0  => (x + G/2)^2 + (y + F/2)^2 = (G/2)^2 + (F/2)^2 - C
    h = -G / 2.0
    k = -F / 2.0
    rad_sq = (G/2.0)**2 + (F/2.0)**2 - C
    if rad_sq < 0:
        r = 0.0
    else:
        r = math.sqrt(rad_sq)
    # answer string: we'll store as tuple values but produce a simple string for comparison
    # round to 3 decimal places for display and checking
    answer_str = f"{round(h,3)},{round(k,3)},{round(r,3)}"
    return question_text, answer_str

def generate_circle_diameter_question():
    x = 0
    y = 0
    m = 0
    c = 0

    while m*x + c == y:
        x = random.randint(-20, 20)
        y = random.randint(-20, 20)
        m = random.randint(-10, 10)
        c = random.randint(-10, 10)

    if m != 0:
        if m == 1:
            if c > 0:
                equation = f"y = x + {c}"
            elif c == 0:
                equation = f"y = x"
            else:
                equation = f"y = x - {-c}"
        else:
            if c > 0:
                equation = f"y = {m}x + {c}"
            elif c == 0:
                equation = f"y = {m}x"
            else:
                equation = f"y = {m}x - {-c}"
    else:
        equation = f"y = {c}"

    question = f"({x},{y}) is a point on a circle C. The equation of the diameter of the circle is {equation}. Find the equation of the circle in standard form."
    
    # Calculate the answer
    # The center is the intersection of the diameter and its perpendicular through (x,y)
    if m != 0:
        # Perpendicular slope
        m_perp = -1/m
        # Center lies on both lines: y = mx + c and y - y1 = m_perp(x - x1)
        # Solve: mx + c = m_perp(x - x1) + y1
        center_x = (m_perp * x - y + c) / (m_perp - m)
        center_y = m * center_x + c
    else:
        # Horizontal diameter, center has same y-coordinate as the point
        center_x = x
        center_y = c
    
    radius = math.sqrt((x - center_x)**2 + (y - center_y)**2)
    
    # Format answer as (x-h)^2 + (y-k)^2 = r^2
    h = round(center_x, 2)
    k = round(center_y, 2)
    r_squared = round(radius**2, 2)
    
    answer = f"(x-{h})^2 + (y-{k})^2 = {r_squared}"
    return question, answer

def generate_line_inclination_question():
    q = random.randint(-10, 9)
    w = random.randint(-10, 10)
    e = random.randint(q + 1, 10)
    r = random.randint(-10, 10)
    
    if w == r:
        r = r + 1
    if r == 11:
        r = random.randint(-10, 9)
    
    question = f"A line passes through the points ({q}, {w}) and ({e}, {r}). Find the angle of inclination for this line to 2 decimal places."
    
    # Calculate the angle
    o = math.atan((r - w) / (e - q)) * 180 / math.pi
    if o < 0:
        o = 180 + o
    
    answer = str(round(o, 2))
    return question, answer

# ---------------- UI: Home Frame ----------------
home_frame = tk.Frame(root, bg="#f0f8ff")

top_bar = tk.Frame(home_frame, bg="#f0f8ff")
top_bar.pack(fill="x", side="top", pady=6)

streak_label = tk.Label(top_bar, text=f"üî• Streak: {streak} days", font=("Arial", 12, "bold"), bg="#f0f8ff", fg="#ff4500")
streak_label.pack(side="left", padx=10)

xp_points_frame = tk.Frame(top_bar, bg="#f0f8ff")
xp_points_frame.pack(side="right", padx=12)
home_xp_label = tk.Label(xp_points_frame, text=f"Total XP: {total_xp}", font=("Arial", 12, "bold"), bg="#f0f8ff", fg="#1e90ff")
home_xp_label.pack(side="top", anchor="e")
home_points_label = tk.Label(xp_points_frame, text=f"Points: {total_points}", font=("Arial", 12, "bold"), bg="#f0f8ff", fg="#32cd32")
home_points_label.pack(side="top", anchor="e")

home_title = tk.Label(home_frame, text="üè† Home Page", font=("Arial", 28, "bold"), bg="#f0f8ff", fg="#ff69b4")
home_title.pack(pady=10)

# emoji canvas
emoji_canvas = tk.Canvas(home_frame, width=760, height=120, bg="#f0f8ff", highlightthickness=0)
emoji_canvas.pack(pady=6)
emojis = ["üî•","‚≠ê","üíé","‚ö°","üéØ"]
emoji_items=[]
for _ in range(12):
    e=random.choice(emojis)
    x=random.randint(30,730); y=random.randint(20,100)
    emoji_items.append(emoji_canvas.create_text(x,y, text=e, font=("Arial",26)))
def animate_emojis():
    for item in emoji_items:
        x,y = emoji_canvas.coords(item)
        y -= 0.8
        if y < -10: y = 130
        emoji_canvas.coords(item, x, y)
    root.after(60, animate_emojis)

quote_title = tk.Label(home_frame, text="üí° Motivational Quote of the Day:", font=("Arial", 14, "bold"), bg="#f0f8ff", fg="#ff1493")
quote_title.pack(pady=(8,0))
quote_label = tk.Label(home_frame, text="", font=("Arial", 12), wraplength=720, justify="center", bg="#f0f8ff")
quote_label.pack(pady=(2,8))

quotes = [
    "'Life's simple. You make choices and you don't look back' - Han Lue",
    "'I live my life a quarter mile at a time.' - Dominic Toretto",
    "Carpe Diem",
    "Seize the present ‚Äî future is unknown.",
    "Savour every moment as if it's your last",
    "Time slips from the palm of your hands like water flows through the mountain cracks"
]
def update_quote():
    d = datetime.now().timetuple().tm_yday
    quote_label.config(text=quotes[d % len(quotes)])

# shop & badges buttons
buttons_frame = tk.Frame(home_frame, bg="#f0f8ff")
buttons_frame.pack(pady=6)
def open_shop(): show_shop()
def open_badges(): show_badges()
shop_btn = tk.Button(buttons_frame, text="üõí Shop", font=("Arial",14,"bold"), bg="#ffa500", fg="white", width=14, command=open_shop)
shop_btn.pack(side="left", padx=12)
badges_btn = tk.Button(buttons_frame, text="üèÖ Badges", font=("Arial",14,"bold"), bg="#1e90ff", fg="white", width=14, command=open_badges)
badges_btn.pack(side="left", padx=12)

# start studying
def show_stopwatch(): hide_all_frames(); stopwatch_frame.pack(fill="both", expand=True)
start_btn = tk.Button(home_frame, text="üöÄ Start Studying!", font=("Arial",18,"bold"), bg="#ffb347", fg="white", command=show_stopwatch)
start_btn.pack(pady=10, ipadx=10, ipady=8)

# xp bar bottom
xp_frame = tk.Frame(home_frame, bg="#f0f8ff")
xp_frame.pack(side="bottom", pady=18)
level_label = tk.Label(xp_frame, text=f"Level {level}", font=("Arial",12,"bold"), bg="#f0f8ff")
level_label.pack(side="left", padx=10)
canvas_width = 520; canvas_height = 36
xp_canvas = tk.Canvas(xp_frame, width=canvas_width, height=canvas_height, bg="#dcdcdc", highlightthickness=2)
xp_canvas.pack(side="left", padx=6)
xp_text = xp_canvas.create_text(canvas_width//2, canvas_height//2, text=f"{current_xp}/{xp_needed}", font=("Arial",12,"bold"))

def update_xp_bar():
    xp_canvas.delete("bar")
    fill = (current_xp / xp_needed) * canvas_width if xp_needed>0 else 0
    xp_canvas.create_rectangle(0,0,fill,canvas_height, fill="#1e90ff", tags="bar")
    xp_canvas.itemconfig(xp_text, text=f"{current_xp}/{xp_needed}")
    level_label.config(text=f"Level {level}")

def add_xp(amount):
    global current_xp, total_xp, level, xp_needed
    total_xp += amount
    current_xp += amount
    while current_xp >= xp_needed:
        current_xp -= xp_needed
        level += 1
        xp_needed += 10
        show_level_up_animation()
    update_home_labels()
    update_xp_bar()

def show_level_up_animation():
    conf=[]
    for _ in range(36):
        x=random.randint(0,canvas_width); y=random.randint(0,canvas_height)
        conf.append(xp_canvas.create_oval(x,y,x+6,y+6, fill=random.choice(["red","yellow","green","blue","purple","orange"])))
    root.after(900, lambda: [xp_canvas.delete(c) for c in conf])
    messagebox.showinfo("Level Up!", f"üéâ Congratulations! You reached Level {level}!")

def update_home_labels():
    home_xp_label.config(text=f"Total XP: {total_xp}")
    home_points_label.config(text=f"Points: {total_points}")
    streak_label.config(text=f"üî• Streak: {streak} days")
    update_xp_bar()

update_quote(); animate_emojis(); update_xp_bar()

# ---------------- Stopwatch Frame ----------------
stopwatch_frame = tk.Frame(root, bg="#f0f8ff")
stopwatch_label = tk.Label(stopwatch_frame, text="00:00:00", font=("Arial",30), bg="#f0f8ff")
stopwatch_label.pack(pady=20)
stopwatch_xp_label = tk.Label(stopwatch_frame, text=f"XP Gained: {session_xp}", font=("Arial",16), bg="#f0f8ff")
stopwatch_xp_label.pack(pady=3)
stopwatch_points_label = tk.Label(stopwatch_frame, text=f"Points Gained: {session_points}", font=("Arial",16), bg="#f0f8ff")
stopwatch_points_label.pack(pady=3)

controls_frame = tk.Frame(stopwatch_frame, bg="#f0f8ff"); controls_frame.pack(pady=16)
def start_stopwatch():
    global stopwatch_running
    if not stopwatch_running:
        stopwatch_running = True
        update_stopwatch()
def pause_stopwatch():
    global stopwatch_running; stopwatch_running = False

start_button_sw = tk.Button(controls_frame, text="Start", font=("Arial",12,"bold"), bg="#32cd32", fg="white", width=12, command=start_stopwatch)
start_button_sw.pack(side="left", padx=8)
pause_button_sw = tk.Button(controls_frame, text="Pause", font=("Arial",12,"bold"), bg="#ff6347", fg="white", width=12, command=pause_stopwatch)
pause_button_sw.pack(side="left", padx=8)

def update_stopwatch():
    global stopwatch_seconds, session_xp, session_points
    if stopwatch_running:
        stopwatch_seconds += 1
        h, rem = divmod(stopwatch_seconds,3600); m,s = divmod(rem,60)
        stopwatch_label.config(text=f"{h:02d}:{m:02d}:{s:02d}")
        session_xp += 1
        session_points += 1
        stopwatch_xp_label.config(text=f"XP Gained: {int(session_xp)}")
        stopwatch_points_label.config(text=f"Points Gained: {int(session_points)}")
        root.after(1000, update_stopwatch)

def start_questions_session():
    global questions_for_session, current_question_index, num_questions, stopwatch_running
    stopwatch_running = False
    minutes = stopwatch_seconds / 60
    if minutes <= 10: num_questions = 1
    elif minutes <= 20: num_questions = 2
    elif minutes <= 30: num_questions = 3
    else: num_questions = 4
    
    # Generate questions - random mix of all three types
    questions_for_session = []
    for _ in range(num_questions):
        # Randomly choose between the three question types
        question_type = random.choice(["circle_eq", "circle_diameter", "line_inclination"])
        if question_type == "circle_eq":
            q_text, q_answer = generate_circle_question_and_answer()
        elif question_type == "circle_diameter":
            q_text, q_answer = generate_circle_diameter_question()
        else:  # line_inclination
            q_text, q_answer = generate_line_inclination_question()
        questions_for_session.append({"question": q_text, "answer": q_answer})
    
    current_question_index = 0
    hide_all_frames(); questions_frame.pack(fill="both", expand=True)
    show_next_question()

take_test_button = tk.Button(stopwatch_frame, text="Take Test and Claim XP", font=("Arial",14,"bold"), bg="#1e90ff", fg="white", width=28, command=start_questions_session)
take_test_button.pack(pady=14)

# ---------------- Questions UI ----------------
questions_frame = tk.Frame(root, bg="#f0f8ff")
question_label = tk.Label(questions_frame, text="", font=("Arial",16), wraplength=720, justify="center", bg="#f0f8ff")
question_label.pack(pady=20)
answer_entry = tk.Entry(questions_frame, font=("Arial",14), width=40)
answer_entry.pack(pady=8)
feedback_label = tk.Label(questions_frame, text="", font=("Arial",12), bg="#f0f8ff")
feedback_label.pack(pady=6)

def submit_answer():
    global current_question_index, xp_multiplier
    if current_question_index >= len(questions_for_session):
        return
    user = answer_entry.get().strip()
    correct = questions_for_session[current_question_index]["answer"]
    
    # Check if this is a circle center/radius question (format: h,k,r)
    if "," in correct and len(correct.split(",")) == 3:
        # Accept a few formats: 'h,k,r' or 'h k r' or "h, k, r"
        def parse_nums(s):
            for sep in (",", " "):
                parts = [p.strip() for p in s.split(sep) if p.strip()!=""]
                if len(parts)==3:
                    try:
                        nums = [float(p) for p in parts]
                        return nums
                    except:
                        continue
            return None
        usr_nums = parse_nums(user)
        cor_nums = parse_nums(correct)
        ok = False
        if usr_nums and cor_nums:
            # compare with tolerance
            ok = all(abs(usr_nums[i]-cor_nums[i]) <= 0.2 for i in range(3))
    else:
        # For other question types, do direct comparison with tolerance for floats
        try:
            user_float = float(user)
            correct_float = float(correct)
            ok = abs(user_float - correct_float) <= 0.01
        except:
            # fallback: compare strings
            ok = user.lower() == correct.lower()
    
    if ok:
        feedback_label.config(text="‚úÖ Correct! XP multiplier +0.1", fg="green")
        xp_multiplier += 0.1
    else:
        feedback_label.config(text=f"‚ùå Incorrect. Correct answer: {correct}", fg="red")
    current_question_index += 1
    root.after(900, show_next_question)

submit_btn = tk.Button(questions_frame, text="Submit Answer", font=("Arial",12,"bold"), bg="#32cd32", fg="white", command=submit_answer)
submit_btn.pack(pady=6)

def forfeit_questions():
    if messagebox.askyesno("Forfeit", "Forfeit remaining questions?"):
        finish_questions_session()
forfeit_btn = tk.Button(questions_frame, text="Forfeit Remaining Questions", font=("Arial",10), bg="#ff6347", fg="white", command=forfeit_questions)
forfeit_btn.pack(side="bottom", anchor="se", padx=10, pady=10)

def show_next_question():
    global current_question_index
    if current_question_index < len(questions_for_session):
        q = questions_for_session[current_question_index]
        question_label.config(text=f"Question {current_question_index+1}: {q['question']}")
        answer_entry.delete(0, tk.END)
        feedback_label.config(text="")
    else:
        finish_questions_session()

def finish_questions_session():
    global total_points, session_xp, session_points, xp_multiplier, streak, last_streak_date
    gained_xp = int(session_xp * xp_multiplier)
    gained_points = int(session_points * xp_multiplier)
    add_xp(gained_xp)
    total_points += gained_points
    session_xp = 0; session_points = 0; xp_multiplier = 1.0
    today = datetime.now().date()
    if last_streak_date is None or last_streak_date != today:
        streak += 1; last_streak_date = today
    update_home_labels()
    messagebox.showinfo("Session Complete", f"You gained {gained_xp} XP and {gained_points} points!")
    reset_stopwatch_session(); show_home()

def reset_stopwatch_session():
    global stopwatch_seconds, session_xp, session_points, xp_multiplier, stopwatch_running
    stopwatch_seconds=0; session_xp=0; session_points=0; xp_multiplier=1.0; stopwatch_running=False
    stopwatch_label.config(text="00:00:00"); stopwatch_xp_label.config(text=f"XP Gained: {int(session_xp)}"); stopwatch_points_label.config(text=f"Points Gained: {int(session_points)}")

# ---------------- Shop Frame ----------------
shop_frame = tk.Frame(root, bg="#f0f8ff")
shop_title = tk.Label(shop_frame, text="üéÅ Loot Box Shop", font=("Arial",24,"bold"), bg="#f0f8ff"); shop_title.pack(pady=12)
cost_label = tk.Label(shop_frame, text="Cost: 20 Points", font=("Arial",14), bg="#f0f8ff"); cost_label.pack()
loot_canvas_w, loot_canvas_h = 760, 220
loot_canvas = tk.Canvas(shop_frame, width=loot_canvas_w, height=loot_canvas_h, bg="#ffffff", highlightthickness=1); loot_canvas.pack(pady=12)
loot_result = tk.Label(shop_frame, text="", font=("Arial",14), bg="#f0f8ff"); loot_result.pack(pady=6)

# Fixed marquee generation - always use the same predictable order
def make_marquee_items():
    # Use fixed order: Triangle, Circle, Square, Hexagon repeated
    palette = {"Triangle":"#ff6b6b","Circle":"#1e90ff","Square":"#4cd137","Hexagon":"#f7c948"}
    fixed_order = ["Triangle", "Circle", "Square", "Hexagon"]
    seq = []
    # Repeat the fixed order multiple times to create a long enough sequence
    for _ in range(8):
        for name in fixed_order:
            seq.append({"name": name, "color": palette[name]})
    return seq

marquee_seq = make_marquee_items()

def buy_lootbox_and_award():
    global total_points
    cost = 20
    if total_points < cost:
        messagebox.showwarning("Not enough points", "You do not have enough points to open a loot box.")
        return
    total_points -= cost
    update_home_labels()
    loot_result.config(text="")
    
    # Determine the awarded badge first
    awarded = badge_random_choice()
    
    # Find the FIRST occurrence of the awarded badge in the marquee sequence
    target_index = -1
    for i, item in enumerate(marquee_seq):
        if item["name"] == awarded:
            target_index = i
            break
    
    if target_index == -1:
        # Fallback - shouldn't happen with our fixed sequence
        target_index = 0
    
    # Calculate the target offset to land the awarded badge in the center
    spacing = 160
    target_offset = target_index * spacing
    
    seq = marquee_seq
    frames = 100  # More frames for smoother animation
    
    # Use instance variables to track animation state
    animation_data = {"i": 0, "offset": 0, "current_speed": 20}
    
    def animate_frame():
        i = animation_data["i"]
        offset = animation_data["offset"]
        current_speed = animation_data["current_speed"]
        
        loot_canvas.delete("all")
        x = -offset
        
        # Draw all items in the sequence
        for j, item in enumerate(seq):
            box_x = x
            box_y = 40
            cx = box_x + 80
            cy = box_y + 60
            
            # Draw the box
            loot_canvas.create_rectangle(box_x+10, box_y+10, box_x+150, box_y+150, fill="#fff", outline="#eee")
            
            # Draw the shape
            if use_sprite_images and item["name"] in sprite_imgs:
                img = sprite_imgs[item["name"]]
                loot_canvas.create_image(box_x+20, box_y+10, anchor="nw", image=img)
            else:
                if item["name"]=="Circle": 
                    loot_canvas.create_oval(cx-30,cy-30,cx+30,cy+30, fill=item["color"], outline="black")
                elif item["name"]=="Square": 
                    loot_canvas.create_rectangle(cx-30,cy-30,cx+30,cy+30, fill=item["color"], outline="black")
                elif item["name"]=="Triangle": 
                    loot_canvas.create_polygon(cx,cy-32, cx-30,cy+22, cx+30,cy+22, fill=item["color"], outline="black")
                elif item["name"]=="Hexagon":
                    r=28
                    pts=[]
                    for t in range(6):
                        ang = math.radians(60*t - 30)
                        pts.extend([cx + r*math.cos(ang), cy + r*math.sin(ang)])
                    loot_canvas.create_polygon(pts, fill=item["color"], outline="black")
            
            # Draw label and probability
            loot_canvas.create_text(box_x+80, box_y+165, text=item["name"], font=("Arial",10))
            chance = next((b["chance"] for b in BADGES if b["key"]==item["name"]),0.0)
            loot_canvas.create_text(box_x+80, box_y+185, text=f"{chance:.1f}%", font=("Arial",9))
            x += spacing
        
        # Highlight box in center
        loot_canvas.create_rectangle(loot_canvas_w//2 - 80, 25, loot_canvas_w//2 + 80, loot_canvas_h - 25, outline="#ff8c00", width=3)
        
        if i < frames:
            # Calculate distance to target
            distance_to_target = abs(target_offset - offset)
            
            # Smart deceleration
            if distance_to_target < spacing * 0.8:
                # Slow down significantly when close to target
                new_speed = max(1, current_speed * 0.6)
            elif distance_to_target < spacing * 2:
                # Moderate deceleration
                new_speed = max(2, current_speed * 0.85)
            else:
                # Gradual deceleration
                new_speed = max(3, current_speed * 0.95)
            
            # Ensure we land exactly on target
            if offset + new_speed >= target_offset:
                new_offset = target_offset
            else:
                new_offset = offset + new_speed
            
            # Update animation data
            animation_data["i"] = i + 1
            animation_data["offset"] = new_offset
            animation_data["current_speed"] = new_speed
            
            root.after(35, animate_frame)
        else:
            # Final position - show awarded badge
            loot_canvas.delete("all")
            cx = loot_canvas_w//2
            cy = loot_canvas_h//2 - 10
            
            # Draw the awarded badge large in the center
            if use_sprite_images and awarded in sprite_imgs:
                img = sprite_imgs[awarded]
                loot_canvas.create_image(cx - img.width()//2, cy - img.height()//2, anchor="nw", image=img)
            else:
                if awarded == "Circle": 
                    loot_canvas.create_oval(cx-90,cy-90,cx+90,cy+90, fill="#1e90ff", outline="black", width=3)
                elif awarded == "Square": 
                    loot_canvas.create_rectangle(cx-90,cy-90,cx+90,cy+90, fill="#4cd137", outline="black", width=3)
                elif awarded == "Triangle": 
                    loot_canvas.create_polygon(cx,cy-100, cx-95,cy+60, cx+95,cy+60, fill="#ff6b6b", outline="black", width=3)
                elif awarded == "Hexagon":
                    r=95
                    pts=[]
                    for t in range(6):
                        ang = math.radians(60*t - 30)
                        pts.extend([cx + r*math.cos(ang), cy + r*math.sin(ang)])
                    loot_canvas.create_polygon(pts, fill="#f7c948", outline="black", width=3)
            
            # Check if player already has this badge
            if awarded in player_badges:
                loot_result.config(text=f"üéâ You obtained: {awarded} badge! (Duplicate)")
            else:
                loot_result.config(text=f"üéâ You obtained: {awarded} badge!")
                player_badges.append(awarded)  # Only add if it's a new badge
            
            update_badges_display()
    
    # Start animation
    animate_frame()

buy_btn = tk.Button(shop_frame, text="Open Loot Box", font=("Arial",14,"bold"), bg="#32cd32", fg="white", command=buy_lootbox_and_award)
buy_btn.pack(pady=6)
back_shop_btn = tk.Button(shop_frame, text="Back to Home", font=("Arial",12), bg="#ff6347", fg="white", command=lambda: show_home())
back_shop_btn.pack(pady=6)

# ---------------- Badges Frame ----------------
badges_frame = tk.Frame(root, bg="#f0f8ff")
badges_title = tk.Label(badges_frame, text="üèÖ My Badges", font=("Arial",24,"bold"), bg="#f0f8ff"); badges_title.pack(pady=10)
badges_list_frame = tk.Frame(badges_frame, bg="#f0f8ff"); badges_list_frame.pack(pady=10, fill="both", expand=True)
# Create the single Back to Home button once (prevent duplicates)
badges_back_btn = tk.Button(badges_frame, text="Back to Home", font=("Arial",12), bg="#ff6347", fg="white", command=lambda: show_home())

def update_badges_display():
    # clear list area but keep the single back button separate
    for w in badges_list_frame.winfo_children():
        w.destroy()
    if not player_badges:
        tk.Label(badges_list_frame, text="No badges yet.", font=("Arial",14), bg="#f0f8ff").pack(pady=8)
    else:
        cols = 4
        for idx, name in enumerate(player_badges):
            r = idx // cols; c = idx % cols
            frame = tk.Frame(badges_list_frame, bg="#ffffff", bd=1, relief="raised", padx=6, pady=6)
            frame.grid(row=r, column=c, padx=8, pady=8)
            canv = tk.Canvas(frame, width=120, height=120, bg="#ffffff", highlightthickness=0)
            canv.pack()
            if use_sprite_images and name in sprite_imgs:
                canv.create_image(0,0, anchor="nw", image=sprite_imgs[name])
            else:
                draw_shape_on_canvas(canv, name, size=100)
            lbl = tk.Label(frame, text=name, font=("Arial",12,"bold"), bg="#ffffff"); lbl.pack(pady=4)
    # show (or re-pack) the single "Back to Home" button at bottom of badges_frame
    badges_back_btn.pack_forget()
    badges_back_btn.pack(pady=10)

# ---------------- Navigation helpers ----------------
def hide_all_frames():
    for w in root.winfo_children():
        w.pack_forget()

def show_home():
    hide_all_frames(); home_frame.pack(fill="both", expand=True)

def show_shop():
    hide_all_frames(); shop_frame.pack(fill="both", expand=True)

def show_badges():
    hide_all_frames(); badges_frame.pack(fill="both", expand=True); update_badges_display()

# ---------------- Start the app ----------------
show_home()
root.mainloop()
